# Classes and Templates

As I have given you my general syntax for an AI, let's focus on Classes and Templates: the main building blocks of the Object World or Object Plane, to express it magically (btw. there has been a professor of programming, who always wanted to base this on magic - it sounded like a magic trick; otherwise purist programmer - kind of semimythos is typical in best programmer's world).

Our classes are similar to the ones of Google Go, additionally they are based on database logic.

Let's base a class around a Function - a Function is going to parse from input to output, and in our cases, from output to input, reverse in time. A function is also a database: we create instance as we associate it with "&", as a deeper object (logic), where our functions can continue running getters, setters and subcalls from outside and inside, as it passes the "returns" and "yields", gathering new calls as tuples of input, templates of output, as well as having structural body of functions and objects: we can construct a virtual "new" constructor on that, to hide this essence from the user.

In addition to it's virtual body, and constructor with it's "unique identifier", as input (can be a factory) or at least output (an unique identifier of instance, where being instance class is rather a special case - it could be random element by fundamental randomization), each function is associated as Controller to all functions running at the same time, modifying the same variables or call's side-effect consistency triggers. For a function with side-effects, some dimension of Time must be passing. It can also register Tables: each Table, with unique name or also, the parameters or call, will contain set of database elements: notice, how similar is Class Instance to the Table Row; so it can register to tables, either directly or through interface casts for coherent tables.

Instead of Time, mathematical Time is passing in logex, our logic automata:

It follows the order of instructions, despite being a logic programming language similar to Prolog. Then, the instructions must follow a logic that they do not produce inconsistencies or unknowns: notice in case of inconsistencies or unknowns, they can produce solids in accelerated and deccelerated scapes: a block of code is thought of, as being ideally run infinitely long from the past, through the present (input), to the future; the past can check the present or estimate it, in case of coordinate system being based on the past (a special case).

Inheritance:
- A is B: A is of type of B, inheriting B's Nature such as Properties and Base Types.
  - if A is several things, the constructor must reproduce input for each class constructor; if it "is", but later, it's important to notice this structure must be able to initialize new class based on history - in case you do not keep enough history, and you are not able to reprocess the birth of this instance, you must cast RunTime Error that you cannot walk from the past, to apply this new generic.
  - A and B can be sets or classes of classes and types.
- B si A: following either from Spanish, or from syntax of some near-bash languages to have "if" and "fi", "case" and "esac" etc. Here, B concludes being A.
- A and B can contain indexes: index, then, is single position in Space (unlike Time), or Time: as the Logic Space is moving in Space and Time, it's Window will move; Eternity will remove the indexes - whole Array creates a generalized sentence, such as "All Cats".
- Each table is either open or closed, or mutable: one can add information to open table; closed table strictly follows it's established logic; and mutable can add, remove and change elements. Constraints might apply to this.
- Controllers will finish, and the variable states of functions ran in parallel, must not conflict. Each permutation, shift in Space (index) or Time (more complicated index, closing elements to relative positions or given constraint or selector).

What happens to Artificial Intelligence, whan A is B?

In addition to variables and constants, as well as input and output, knowledge can exist in all those coordinate systems: indexes, much like classificators, can divide this space or time into arrays of parallel instances; knowledge must have static index of some kind, or logic to be stored. Artificial Intelligence optimizer can optimize the knowledge: function can create outputs etc. on estimation levels, then. The process will use key points, where non-key points automatically pass the same sequences, even artificially with constant random seeds, but very naturally, from beginning or last key point (more complex calculations might give intermediate points, where Time is relative to Hanging or not finishing, especially for real-time, human-used, or especially long sequences; whether something will finish, is relative to Time: use the real-life Turing paradox, which is sometimes solved by runtime measurement, for example in Mozilla Firefox or other [I think, later] browers): creative keys will produce side-effect relations, unpredictable basis, or even random numbers to your calculus. Try to back-trace: it fits the optimizer, which can apply Future Tensions to the variables; this Tension can take effect even in relation to changed variables or alternate realities, where optimizer took an alternative track. Notice we are talking in terms of "logical time": you take some values as estimations, and pass one potential of Time; from consistency relations, you now have another beginning to Time, which is more optimal estimation: you use back-tracking, but also be aware the relation is changing in changing coordinate systems, which is not part of modern GPL - once the value changed, you cannot use the past values for backpropagation, which would also consider the space; relations in Space would still change in relation to this hypothetical aspect of the variables. To do this, the past starts catalyzing, and in evolution: you see the past and future relation is repeating, so the logical machine standing "still" in evolution, is like having the Past, Present and Future in Z, X, Y, long-term variables, but trees of local relations to pasts, presents and futures of local points, in sub-zero replicance, z, x and y. Even X is unknown: it's the current space. Capital Z is the Visionary element with Epic memories, the Importance of the Past; Y is the Visionary element with future lights, whereas X is the Visionary element to understand the context of your present moment. External X, exceeta, is to join the future to the past: the future outcome, how it relates to the past income; the future success, how it relates to the past sense of importance. Material space of the Future, but the Vision-Truth space of the Past will change, living their eternal lives: who in the past is you, and what's the meaning of their action, is a complex matter of Schroedinger's field, which calculates each moment and point to the infinity: it is, in some complex time, still open to somebody, who is coming. Life is infinity: while you pass the moment, the moment won't pass unless the infinity is over, which happens in the deep dream, metastate of changing logic (I Ching, the Ching), the limit values of open systems: permutating forever, but we are Empty to Unknowns: Enlightenment brought is that suddenly, the Unknown is All that Exists; it's the Eternal Vibration of Time.

Know: this is the relation of Weights and Biases of your Deep Learning, or the unknowns in your progressive Machine Learning algorithms. Each of these is compatible to our language, which still has also a static syntax, a basic understanding - a programmable element, subconscious to the Know of the AI, but rather essential functions it can reflect on by itself as we build a *metaconsciousness* - something based on Attention Mechanism like structure.

This Know, in relation to the structures:
- Array-element relationship:
  - Each Element can have local Know, for example squares on an image can have their local position and size.
  - Elements can have common Know: the same Type or Class is shared through all elements in Array, adding a Know, which is constant to the changing index of their element position. Then, the same values are changed for all the squares iterated over in CNN; as the input-output combinations flow through, the object logic for all the instances is common.
  - Array itself as a *collection* or *singularity* of it's elements, as symbols were often used in math and logic in the past, now more by selected authors: for open classes, this even transcends to Symbols and Archetypes, rather AI-learnt "non-intentionally living things", which compare the patterns with unknowns. Mathematical collection comes by closed, or temporarly / locally closed spaces for internal queries: instead of ever-unfolding Symbol with it's "secret truth", a set of elements has some common property of how their value relates to it's key. For example, we can say, "most cats are not blue" - and object "Cat" representing a cat, probably it's not blue; then "most" of the "Cats" are not blue. It was thought cats are never blue, but we have the swimming cats, for example. Array, for example, for each object property, can contain it's collectors, for example statisticals or aggregates: in relation to "blueishness" of each cat, a collection merges this into "general blueishness" and normalizes that they can be compared by various collection-item relationships.
  - Array can be grouped: while indexes, which create tables as their Classes, or join to bigger tables, to support "full SQL", they can be indexed: for example, divisor could be used.
- Set operations on classes, tables, arrays:
  - Plus: add items.
  - Minus: remove items.
  - Multiply: exhaust combinations, but allow "where" for choosing a combination set.
  - Divide: values, which generalize some property, such as A % 5 would generalize A to count into groups of five, as in an open-space game people count themselves into groups: then, for each number from zero to four, one group can be made, as well as it's generalization, which is more definitely kept - for example, you can view statistics of groups and list their elements into arrays, perhaps trivially.
  - This, because dimensions marked as A[1] could also be more complex: A[x = 1, y > 4] to produce "WHERE"-like arguments.
  - Leave it AI-open (to "know"), how to solve conflicting relations of whether the elements are arrays or elements - for example, whether an element or it's subelements should be added to array.
  - Plus and minus could be prefix and suffix operations with order: adding or removing from beginning or end, in given order.
- Class-family relationship:
  - Class can belong to family: they share a common property or interface. Again, each class has local element of this family, as well as the family has a collection element: while possibly bigger or more precise elements of collection are changed together, such as having capitalized name of the variable or class, the possibly less precise or more local classes in the family have multiplied structure of this. Here, subitems can also be capitalized or not.
- Divisions / groupings: one can divide class into one aggregator with parent, or group it into slices or subsets of aggregators, possibly unique and exhausting: for example, each size of cats is estimated, which color they could have.
- Friendship of indexes: it must be able to solve a conflict where index is created on both sides, and propagated to both sides - for example, table having index of elements means a row having position of this index, backlink to table row. Both create and destroy them as they are created and destroyed: this separate logic must become together that they either exist or do not exist; not an infinite cycle of responding to each-ones triggers, or any other non-coherent function, which easily occurs when this property is not defined.
- Classes and Families themselves:
 - As metaobjects, containing for example the Help blocks and API interfaces or callers, the relationship also means that aggregator of parent and instance elements of each object are present.
 - For example, "Cars" are "meant to be driven". This could be learnt to be rather than Collection, a metaproperty or definition: then, how different cars are meant to be driven, can create a collection, for which this is statistical, simplified generalization. For attributes of things, a metatemplate can connect Cars, Planes etc., to show the property and relevance of the item to be "driven", instead of, for example, "flied" or "jumped with" or simply "destroyed". A subclass can be a wrecking car.

