# Syntactic Sugar for an AI

Let's go a little deeper with a syntax for an AI.

Our aim:
- Artificial Intelligence is a free-language, free thinker.
- Logical Machine is a strict-syntax, rigid scientist.

They look syntactically different and while I was thinking of optimization scenarious even as a child: now we see matrix as a good logical machine completes this. Still, I failed in this: how to join this freedom with constraints of logic.

## Functions

Artificial intelligence is solving the functions in similar manner:

function {AIOptimizer * var step}(var input) : var output {
    # Define knowledge
    know weightsandbiases;

    # Approach the result by step

    return output
}

This function, semantically:
- It has input and output
- It allows to call it with input and output, one assigns output to the function call.
- One can operate with the function, such as allowing multiplication with step size.

This allows to define logic and functions freely from logical systems and artificial intelligences.

Moreover, our artificially intelligent program cannot be separated, by it's form, from identical logical program. For example, step size calculation might be such that obviously, it's indefinitely approaching the result.

Herein, an "imagination factor" could be added: on real axe, there would be realistic, supposed result; while on imaginary axe, there could be a factor, which can grow as one approaches the result. In case it would close the final solution, it might prove it to logic machine; in case the logic machine has the necessary prerequisite, it would solve it.

## Memory->Disk->Internet

The solvers are stable structure, which can be kept in memory, disk or internet. The same instance can be linked from memory to disk or from disk to internet to make it more permanent and public.

Each program would be permanently active, until it's deleted, and the results would gradually improve.

The karma and attention cycle would keep the process going based on focus and importance.

## Backpropagation

Each function, such as "A = B", could be enable to:
- Run forward: commands are interpreted sequentially, and "A = B" results in assigning the variable "A" a value of "B".
- Run backward: commands are interpreted in reverse order, and the same "A = B" instead results in assigning variable "B" the value of "A".

This gives strict syntax to backpropagation, therefore it's assignation and consequence are defined.

## Instances and Classes

If you have an array of similar instances, such as array of vectors of 20 bytes:
- Each instance can have it's specific tensor memory, which is it's own memory.
- The whole array can have it's memory or parameters, for example number of items, sum of their values, or the array itself as it's content.

These are examples of things, which won't generalize. These tensors are normal variables, which contain constants, variables and knowledge - knowledge responds to biases and optimizes towards it's goal.

To have class of vectors of 20 bytes, where each member of an array belongs to this class:
- We set up common knowledges, or constants and variables, and each member of this array has the same memory of weights and biases.

Consider CNN, the image processing, where a small square of some pixels will move through the whole image. Instead of thinking of this in time, and terms of the process: imagine you just define the same class of x * y pixels of this image. Programmatically, it means assigning certain type to these striped areas of memory; mathematically, it means a definition that of this type of image, internal area of size x * y is a nested type; we define that all pixel areas of size x * y belong to our class or type. The class is formed by singleton properties of the elements.

This syntax might be generalized, even if generalized form is rather programmable than completely supported.

## Proofs

I think the provers tend to be very complex.

In programming, more easy than the proof is to state that something is or defines a list of combinations - this means, you can combine the possibilities or quantum superset -; second, you expect a certain result. This kind of prover is logically very simple and while you might not get rigid mathematical proofs based on your syntax - this is not what programmers do; rather you program in a way that your program is sensitive to it's correctness.

Notice that in many kinds of proof logic you find out that you are very close to being bound to closed logic, where a list of possibilities is also considered to rather be a complete list. Metaphysically, it's a big difference whether B is implied by A, and A is true, or whether B is simply true: each condition of your system might change, and for universal definition of A and B, the most simplified logic of closed binary tables becomes complex in open space, in incompleteness or "dukkha" of your logic.

For each table you define on your own, whether it's closed from the start, or whether your logic guarantees that the table of possible goals or implications is closed itself.

What means open? For example, you have defined a certain machine, such as Game of Life of Cellular Automata: you define many rules, which are tautologically identical to proofs about other automatas; despite this, in your automata the special case if final and tautologically true, it can be proven. In open logical system, the case that in other machines, the same definitions would yield to different logic, definitely means that you won't close such tautologies based on your case of this being *your* final system - instead, some things are *metaphysical implications*, for example A and B are not simply both true in some case, but it's very important whether A => B for two True constants, or whether A and B simply are.

In closed system, from A => B, you could reason also backwards in some special cases: for open systems, the existence of such simplistic tables and each forward and backward implication becomes more complicated; moreover, one should give consideration to implementations, which are not certain at all ("very open systems") - in the latter case, the logical fact you gave might not hold as you further clarify your paradigm, facts and their outcomes.

"Laegna Logex" is where I implemented such description of the "Dukkha" or "Imperfection": _logic itself_ could be perfect, immanent and "all-mighty", which is a separate topic; the thing we do with paper and pencil, in such case, could not be logic. We cannot discard our ability to think and argue logically - rather, the logic must be kind of conscious or aware of it's imperfection. I state my logic is "practical", where I define "pract" simply as "mistake" in my language; this means I have real and imaginary axes for my logic - you can compare it to having rather weights and biases than final values; such kind of logic appears if, additionally to being perfect and final, you rather assign it a property of being real, of existing in form of perception, information, calculation of yours. The closes thing you can get to logic, this is by which you could define it's actual form, capable of being present - this, already, is rather logecs itself; it's kind of impossible to be proven by logic, unless the logic is based on this proof (by which, it's a tautology itself).

## Variable assignment

Typical thing we are doing is mess with units and orders of calculations.

A = B + 20.

A = incby20(B).

This is allowed in most language and means you get A by adding 20 to B.

A - 20 = B.

decby20(A) = B.

This is an equivalent, but not found in imperative paradigm. In reality, it would optimize out and still allow us coherent syntax to cover different things in identifyable forms, for example a function and it's opposite function can be properly connected.

### Units

Units are most typical subcase of such variable assignment:

a cm = 20 m.

Variable "a", in cm, is assigned the value of 20 m. Without changing the syntax, associating space with some multiplication or combination of multiplication and addition, we easily get this in some case of previously given syntax: for example in "a * cm = 20 * m", it solves if "cm" and "m" are constants, in which case "a" could be changed to fit this.

We can also create functions:

cm(a) = m(20).

This also fits the same convention or syntax.

We can also have specific "unit" type, or template of calculation, for example 4, 8 imre could mean that 4, 8 has imaginary-real unit of complex number, where type is associated with this order. This complex syntax could involve that mathematical type imre has constructor of two variables, and it can be deconstructed to form suitable for conversion to other types.
